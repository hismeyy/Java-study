# 一、并发编程简介

## 1、什么是并发编程

1. 同一台电脑
2. "处理"多个任务
3. 从编程上来说：计算机可以在一个时间段内，执行多个任务
4. 从CPU硬件层面上说：是一个或多个物理CPU在多个程序之间多路复用，提高对计算机资源的利用率
5. 从调度算法上来说：当任务数量多于CPU的核数时，并发编程能够通过操作系统的任务调度算法，实现多个任务一起执行

## 2、并发编程的重要性

对于一个 Java 程序员而言，能否熟练掌握并发编程是判断他优秀与否的重要标准之一。因为并发编程是 Java 语言中最为晦涩的知识点，它涉及操作系统、内存、CPU、编程语言等多方面的基础能力，更为考验一个程序员的内功。

## 3、并发编程的特性

1. 原子性
2. 可见性
3. 有序性

# 二、操作系统的并发

## 1、并发编程的定义

定义：并发编程是指在一台处理器上 “同时” 处理多个任务。并发是在同一实体上的多个事件，**多个事件在同一时间间隔发生**

意义：开发者通过使用不同的语言，实现并发编程，充分的利用处理器（CPU）的每一个核，以达到最高的处理性能，提升服务器的资源利用率，提升数据的处理速度。

## 2、从CPU谈并发编程

CPU的频率远远比主存的频率快，因此在线程处理的时钟周期内，CPU常常需要等待主存，这样就浪费了资源。所以CPU在硬件层面上，CPU执行线程的切换，因为切换频率非常快，所以我们感官上认为是计算机同时执行多个任务。

为了避免长时间的线程等待，我们一方面可以提高硬件指标（比如多级高速缓存），另一方面是引用并发概念，充分利用处理器的每个核，减少CPU资源等待的时间，以达到最高的处理性能

## 3、操作系统，进程，线程之间的联系与区别

操作系统包含多个进程的容器，每个进程又包含了多个线程的容器

1. 什么是进程

   官方定义：进程是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位

   人话：进程就是一种程序的运行

   Tips：操作系统分配的资源和调度对象其实就是CPU时间片

2. 什么是线程

   官方定义： 线程是操作系统能够进行资源调度的最小单位，它被包含在进程之中，是进程中的实际运作单位，每个线程执行的都是进程代码的某个片段，特定的线程总是在执行特定的任务。

   人话：线程是操作系统进行资源调度的最小单位，他在进程中包含，每个线程处理进程中某个代码片段，执行特定的任务

3. 线程和进程的区别

   诞生：先有进程，后有线程。进程由于资源利用率、公平性和便利性诞生，线程则是为了提高 CPU 的利用率、提高程序的执行效率而诞生

   概念：**进程是资源分配的最小单位**。 线程是程序执行的最小单位（线程是操作系统能够进行资源调度的最小单位，同个进程中的线程也可以被同时调度到多个 CPU 上运行），线程也被称为轻量级进程

   内存共享：默认情况下，进程的内存无法与其他进程共享（进程间通信通过 IPC 进行）。 线程共享由操作系统分配给其父进程的内存块

## 4、串行、并行与并发

1. 串行：顺序执行，按步就搬。在 A 任务执行完之前不可以执行 B
2. 并行：：同时执行，多管齐下。指两个或两个以上事件或活动在同一时刻发生。在多道程序环境下，并行性使多个程序同一时刻可在不同 CPU 核心上同时执行
3. 并发：：穿插执行，减少等待。指多个线程轮流穿插着执行，并发的实质是一个物理 CPU 在若干道程序之间多路复用，其目的是提高有限物理资源的运行效率

![](https://img.yublog.top/firm-img/202301121022520.png)

# 三、Java线程内存模拟

## 1、什么是Java的内存模拟

Java 内存模型（即 Java Memory Model，简称 JMM）本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。

## 2、Java 线程的私有内存和主内存

![img](https://img-blog.csdnimg.cn/6e2ff8acd4994071bd2ced060e9e5bd1.png)

1. **工作内存（私有）**：由于JVM 运行程序的实体是线程，而每个线程创建时 JVM 都会为其创建一个工作内存（栈区和PC寄存器），用于存储线程私有的数据。线程私有的数据只能供自己使用，其他线程不能够访问到当前线程私有的内存空间，保证了不同的线程在处理自己的数据时，不受其他线程的影响
2. **主内存（共享）**：Java 内存模型中规定所有变量都存储在主内存（堆区和方法区），主内存是共享内存区域，所有线程都可以访问。从上图中可以看到，Java 的并发内存模型与操作系统的 CPU 运行方式极其相似，这就是 Java 的并发编程模型。通过创建多条线程，并发的进行操作，充分利用系统资源，达到高效的并发运算

## 3、主内存操作共享变量需要注意的事项

1. 确定是否是多线程环境：多线程环境下操作共享变量需要考虑线程的安全性；
2. 确定是否有增删改操作：多线程环境下，如果对共享数据有增加，删除或者修改的操作，需要谨慎。为了保证线程的同步性，必须对该共享数据进行加锁操作，保证多线程环境下，所有的线程能够获取到正确的数据；
3. 多线程下的读操作：如果是只读操作，对共享数据不需要进行锁操作，因为数据本身未发生增删改操作，不会影响获取数据的准确性。

# 四、Java多线程的创建

## 1、Thread类

1. 位置java.lang包下Thread类，它实现了Runnable接口

2. 常用方法

   | 方法                  | 作用                                                         |
   | --------------------- | ------------------------------------------------------------ |
   | start()               | 导致此线程开始执行; Java虚拟机调用此线程的`run`方法          |
   | run()                 | 通常需要重写 Thread 类中的此方法，将创建要执行的操作声明在此方法中 |
   | currentThread()       | 静态方法，返回代码执行的线程                                 |
   | getName()             | 获取当前线程的名字                                           |
   | setName()             | 设置当前线程的名字                                           |
   | sleep(long millitime) | 让当前进程睡眠指定的毫秒数，在指定时间内，线程是阻塞状态     |
   | isAlive()             | 判断进程是否存活                                             |
   | wait()                | 线程等待                                                     |
   | notify()              | 线程唤醒                                                     |

3. 多线程的三个创建方法
   - 继承 Thread 类的方式创建线程
   - 实现 java.lang.Runnable 接口
   - 实现 Callable 接口

## 2、方法一

1. 继承Thread类
2. 重写run方法

```java
public class ThreadExtendTest extends Thread{
    @Override
    public void run() {
	    //run方法内为具体的逻辑实现
        System.out.println("create thread by thread extend");
    }
    public static void main(String[] args) {
        new ThreadExtendTest(). start();
    }
}
```

## 3、方法二

> 由于 Java 是面向接口编程，且可进行多接口实现，相比 Java 的单继承特性更加灵活，易于扩展，所以相比方式一，更推荐使用方式二进行线程的创建。

1. 实现 Runnable 接口
2. 重写run方法

```java
public class ThreadRunnableTest implements Runnable{
    @Override
    public void run() {
		//run方法内为具体的逻辑实现
        System.out.println("create thread by runnable implements");
    }
    public static void main(String[] args) {
        new Thread(new ThreadRunnableTest()). start();
   }
}
```

**注意：**可以使用匿名内部类

## 4、方法三

> 方式一与方式二的创建方式都是复写 run 方法，都是 void 形式的，没有返回值。但是对于方式三来说，实现 Callable 接口，能够有返回值类型。

1. 实现 Callable 接口
2. 重写call方法

```java
public class ThreadCallableTest implements Callable<String> {
    @Override
    public String call() throws Exception {
	    //call 方法的返回值类型是 String
	    //call 方法是线程具体逻辑的实现方法
        return "create thread by implements Callable";
    }
    public static void main(String[] args) throws ExecutionException, InterruptedException{
        FutureTask<String> future1 = new FutureTask<String>(new ThreadCallableTest());
        Thread thread1 = new Thread(future1);
        thread1. start();
        System.out.println(future1.get());
    }
}
```

# 五、多线程join方法

[(96条消息) Java并发编程基础（一篇入门）_行者无疆_ty的博客-CSDN博客](https://blog.csdn.net/a321123b/article/details/123389278)
